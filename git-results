#! /usr/bin/python2

"""Created by Walt Woods, 2014"""

from __future__ import print_function

import argparse
import datetime
import os
import random
import re
import shlex
import shutil
import subprocess
import sys
import textwrap
import threading
import time
import traceback

ABORT_SUFFIX = '-abrt'
FAIL_SUFFIX = '-fail'
RUN_SUFFIX = '-run'
SUFFIXES = [ '', ABORT_SUFFIX, FAIL_SUFFIX, RUN_SUFFIX ]

class FolderState(object):
    """An object that tracks which files exist at init and at another time,
    and can copy changes to another folder."""

    def __init__(self, dir, resultsDir):
        self._dir = dir or os.path.abspath('.')
        self._resultsDirRel = os.path.relpath(resultsDir, self._dir)
        if not self._resultsDirRel.startswith(".."):
            while True:
                rdr = os.path.split(self._resultsDirRel)[0]
                if not rdr:
                    break
                self._resultsDirRel = rdr[0]
        self._files = set()
        self._scan(self._dir)


    def copyResultsTo(self, dir, trimCommonPaths = False):
        """Copy changes from self._dir to dir.  Use most common path."""
        allChanges = set()
        self._scanChanges(self._dir, allChanges)

        prefix = None
        for c in allChanges:
            if prefix is None:
                prefix = c
            else:
                while not c.startswith(prefix):
                    prefix = os.path.dirname(prefix)

        for c in allChanges:
            # Add 1 to len(prefix) so that we don't include the preceding slash,
            # which would make os.path.join treat it as an absolute
            target = os.path.relpath(c, self._dir)
            if trimCommonPaths:
                target = os.path.relpath(c, prefix)
            target = os.path.join(dir, target)
            safeMake(os.path.dirname(target))
            shutil.copy2(c, target)


    def _isBanned(self, path):
        if path == os.path.join(self._dir, self._resultsDirRel):
            return True
        return False


    def _scan(self, path):
        if self._isBanned(path):
            return
        for f in os.listdir(path):
            ff = os.path.join(path, f)
            if os.path.isfile(ff):
                self._files.add(ff)
            if os.path.isdir(ff) and not os.path.islink(ff):
                self._scan(ff)


    def _scanChanges(self, path, changeset):
        if self._isBanned(path):
            return
        for f in os.listdir(path):
            ff = os.path.join(path, f)
            if os.path.isfile(ff) and ff not in self._files:
                changeset.add(ff)
            elif os.path.isdir(ff) and not os.path.islink(ff):
                self._scanChanges(ff, changeset)



def checked(cmd, nonZeroOk = False, shell = False):
    cmd = shlex.split(cmd)
    p = subprocess.Popen(cmd, stdout = subprocess.PIPE,
            stderr = subprocess.PIPE, shell = shell)
    p.communicate()
    r = p.poll()

    if r != 0 and not nonZeroOk:
        raise Exception("Command '{}' failed with {}".format(cmd, r))


def checkedOutput(cmd):
    """Raises an Exception if cmd fails; returns stdout otherwise."""
    cmd = shlex.split(cmd)
    p = subprocess.Popen(cmd, stdout = subprocess.PIPE,
            stderr = subprocess.PIPE)
    stdout, stderr = p.communicate()
    return stdout


def copySymlinks(frm, to):
    """Copies all symlinks recursively from directory frm to directory to."""
    for f in os.listdir(frm):
        ffrm = os.path.join(frm, f)
        fto = os.path.join(to, f)
        if os.path.islink(ffrm):
            linkTo = os.readlink(ffrm)
            os.symlink(linkTo, fto)
        elif os.path.isdir(ffrm) and os.path.isdir(fto):
            copySymlinks(ffrm, fto)


def ensureGitignore(resultsDir):
    if checkedOutput("git status {} --porcelain".format(resultsDir)).strip():
        with open('.gitignore', 'a') as f:
            f.write("\n{}".format(resultsDir))


def tee(infile, *files):
    """Thanks to http://stackoverflow.com/a/4985080/160205, tee lines from the
    given file to one or more other files.
    """
    def fanout():
        for line in iter(infile.readline, ''):
            for f in files:
                f.write(line)
        infile.close()
    t = threading.Thread(target = fanout)
    t.daemon = True
    t.start()
    return t


def runExperiment(dir, resultsDir, commitTag, trimCommonPaths):
    """Given a directory to initialize and run our experiment in 'dir', run it
    and put results in 'resultsDir'

    dir can be None for current dir (not a temporary directory!)
    """

    if dir is None:
        dirRelative = '.'
    else:
        dirRelative = dir
        dir = os.path.abspath(dir)
    resultsDirRelative = resultsDir
    resultsDir = os.path.abspath(resultsDir)
    odir = os.getcwd()
    tmpDirLink = os.path.join(resultsDir, 'git-results-tmp')
    try:
        os.symlink(os.path.abspath(dir or '.'), tmpDirLink)

        if dir is not None:
            os.chdir(dir)
            checked('git init')
            checked('git remote add origin file://{}'.format(odir))
            checked('git fetch origin {}'.format(commitTag))
            checked('git reset --hard FETCH_HEAD')
            copySymlinks(odir, dir)
            for grFile in [ "git-results-build", "git-results-run" ]:
                shutil.copy2(os.path.join(odir, grFile), os.path.join(dir,
                        grFile))

        preBuild = time.time()

        print("Building {} in {}".format(commitTag, dirRelative))
        p = subprocess.Popen(os.path.abspath('./git-results-build'),
                shell = True)
        p.communicate()
        r = p.poll()
        if r != 0:
            print("== BUILD FAILED ==")
            sys.exit(1)

        # Now that we've built it, snapshot the folder so we can copy whatever
        # changed as results.  We'll be a little smart and take off the greatest
        # common path too...
        fs = FolderState(dir, resultsDir)

        print("Running {} in {}".format(commitTag, dirRelative))
        print("=" * 79)
        print("=" * 79)
        preRun = time.time()

        threads = None
        didAbort = False
        try:
            # Special handling for our runner script
            line_buffered = 1
            output = open('{}/stdout'.format(resultsDir), 'w', line_buffered)
            error = open('{}/stderr'.format(resultsDir), 'w', line_buffered)
            p = subprocess.Popen(os.path.abspath('./git-results-run'), shell = True,
                    stdout = subprocess.PIPE, stderr = subprocess.PIPE)
            threads = [ tee(p.stdout, output, sys.stdout),
                    tee(p.stderr, error, sys.stderr) ]
            [ t.join() for t in threads ]
            r = p.wait()
        except KeyboardInterrupt:
            # Child got Ctrl+C,
            print("== CTRL+C caught by git-results; child should exit as per "
                    "CTRL+C semantics")
            [ t.join() for t in threads ]
            r = p.wait()
            didAbort = True

        print("=" * 79)
        print("=" * 79)

        # If we reach here, everything ran OK, so copy files
        print("Copying results to {}".format(resultsDirRelative))
        fs.copyResultsTo(resultsDir, trimCommonPaths)

        allDone = time.time()
        with open(os.path.join(resultsDir, 'git-results-message'), 'a') as f:
            f.write("\n\n")
            f.write("{} after {}s\n".format("OK" if r == 0 else "FAIL",
                    allDone - preRun))
            f.write("Build took {}s\n".format(preRun - preBuild))

        if r != 0:
            error.write(("\n\ngit-results detected abnormal program "
                    "termination: {}\n").format(r))
            print("Non-zero exit status after {}: {}".format(allDone - preRun,
                    r))
        else:
            print("OK after {}".format(allDone - preRun))
        return r, didAbort
    finally:
        os.chdir(odir)
        os.unlink(tmpDirLink)


def safeMake(path):
    try:
        os.makedirs(path)
    except OSError, e:
        # exists
        if e.errno != 17:
            raise


def setupExperiment(resultsDir, shouldCommit, tag, message):
    """Sets up the experiment skeleton and commits the git repo to an acceptable
    state.

    Returns the directory for results (absolute path), dated symlink path (for
    rollback / updated), latest symlink path, and the commit tag to run.
    """
    resultsBaseRelative = resultsDir
    resultsDir = os.path.abspath(resultsDir)
    if not os.path.exists(os.path.join(resultsDir, ".git")):
        curdir = os.getcwd()
        safeMake(resultsDir)
        os.chdir(resultsDir)
        checked("git init")
        # If we don't make a file, it looks like results is always ignored even
        # though it isn't.  Luckily, we need a .gitignore anyway
        with open("{}/.gitignore".format(resultsDir), 'w') as f:
            f.write(".tmp")
        os.chdir(curdir)

    # Now that it's made, make sure it's ignored
    ensureGitignore(resultsBaseRelative)

    # Allow / encourage running same tag several times.  We'll use /1, /2, etc
    n = 1
    while True:
        tagDir = os.path.join(resultsBaseRelative, tag + "/{}".format(n))
        if not any([ os.path.exists(tagDir + s) for s in SUFFIXES ]):
            break
        n += 1
    pureTag = tag
    tag = tag + "/{}".format(n)
    gitTag = "{}/{}".format(resultsBaseRelative, tag)

    if not message:
        cleanMessage = gitTag
    else:
        cleanMessage = message.replace('"', '\\"').replace("&", "\\&"
                ).replace("|", "\\|").replace("!", "\\!")

    # Check the state of our git repo
    if checkedOutput("git status --porcelain").strip():
        # Need to commit, if we can
        if not shouldCommit:
            raise ValueError("Repository has unsaved changes; use -c to commit "
                    "automatically.")

        # Make sure git-results-build and git-results-run are ignored
        gb = checkedOutput("git status git-results-build --porcelain").strip()
        if gb and gb.startswith("?"):
            # Would be added.  Don't do that!
            with open(".gitignore", "a") as f:
                f.write("\ngit-results-build")
        gb = checkedOutput("git status git-results-run --porcelain").strip()
        if gb and gb.startswith("?"):
            # Same
            with open(".gitignore", "a") as f:
                f.write("\ngit-results-run")

        # If this fails, the branch didn't exist or we're already on it, both
        # of which are fine
        checked("git branch -D git-results", True)
        checked("git branch --no-track git-results", True)
        checked("git checkout git-results")
        checked("git add .")
        checked('git commit -m "{}"'.format(cleanMessage))

    curCommit = checkedOutput("git rev-parse HEAD").strip()

    # Actually make our folder
    tagDirRun = tagDir + RUN_SUFFIX
    safeMake(tagDirRun)

    # Dated linkage
    now = datetime.datetime.now()
    dated = os.path.join(resultsDir, 'dated', now.strftime("%Y"),
            now.strftime("%m"))
    safeMake(dated)

    linkAs = os.path.join(dated, "{}-{}{}".format(now.strftime("%d"), tag,
            RUN_SUFFIX))
    safeMake(os.path.dirname(linkAs))
    parentLevel = 2 + len(tag.split('/'))
    os.symlink("{}{}{}".format('../' * parentLevel, tag, RUN_SUFFIX),
            linkAs)

    latestLinkAs = os.path.join(resultsDir, 'latest', pureTag + RUN_SUFFIX)
    safeMake(os.path.dirname(latestLinkAs))
    for s in SUFFIXES:
        linkPath = os.path.join(resultsDir, 'latest', pureTag + s)
        if os.path.exists(linkPath):
            os.unlink(linkPath)
    os.symlink(
            "{}{}{}".format('../' * len(pureTag.split('/')), tag, RUN_SUFFIX),
            latestLinkAs)

    # Add our tag to the git repo
    checked('git tag -a -m "{}" {}'.format(cleanMessage, gitTag))

    # Write our message file
    with open(os.path.join(tagDirRun, "git-results-message"), "w") as f:
        f.write("{}\n{}\n".format(gitTag, "=" * min(79, len(gitTag))))
        if message:
            f.write("{}\n".format(message))
        f.write("\nCommit: {}".format(curCommit))
        f.write("\n\ngit-results-run\n---------------\n")
        f.write(open('git-results-run').read())
        f.write("\n\ngit-results-build\n-----------------\n")
        f.write(open('git-results-build').read())

    return tagDirRun, linkAs, latestLinkAs, gitTag


def checkTag(s):
    """Takes a string s and returns it, if it is a tag."""
    if re.search("^[a-zA-Z0-9_/-]+$", s) is None:
        raise ValueError("Tag must match regex [a-zA-Z0-9_-/]+")
    if s.startswith('dated'):
        raise ValueError("Tag may not start with 'dated'")
    if s.startswith('latest'):
        raise ValueError("Tag may not start with 'latest'")
    if s.strip('/') != s:
        raise ValueError("Tag may not begin or end with '/'")
    return s


def safeRollback(d):
    """Delete d and all parent directories (up to most common directory with
    current directory)
    """
    try:
        os.removedirs(d)
    except OSError, e:
        # Directory not empty
        if e.errno != 39:
            raise


def run(programArgs = None):
    if not os.path.isdir('.git'):
        print("Must be used in a git directory!")
        sys.exit(1)

    ap = argparse.ArgumentParser(description = "A git extension for cataloging "
            "computation results")
    ap.add_argument("-d", "--dir", default = "results", help = "Directory used "
            "to store results.  Automatically created and set up as a git "
            "repo.  Also automatically added to .gitignore")
    ap.add_argument("-p", "--path", action = 'store_true',
            help = "Supercedes -d and normal default tag argument.  The first "
                "path element in the tag argument becomes the results "
                "directory, and the rest becomes the tag.  Useful for e.g. "
                "tab completion in a console.")
    ap.add_argument("-i", "--in-place", action = 'store_true',
            help = "Do the build in place.  If you use this, you can't run "
                "several simultaneous git results calls on the same repo.  "
                "Recommended when you're trying to get a build working, or "
                "testing short experiments, but not otherwise.")
    ap.add_argument("-c", "--commit", action = 'store_true',
            help = "If there are uncommitted changes, automatically commit "
                "with the message as given.")
    ap.add_argument("-t", "--trim", action = 'store_true',
            help = "Trim output paths to most common denominator.  That is, if "
                "the application creates folder results/a.txt, then since the "
                "results/ path is part of all created files, it will be "
                "trimmed (leaving just a.txt).")
    ap.add_argument("-m", "--message", help = "Commit message / "
            "git-results-message content paired with results.  If unspecified, "
            "we'll pop open an editor for you (like git commit)")
    ap.add_argument("tag", help = textwrap.dedent("""
            Path to organize these results under.  For instance, giving a tag of parity/squids
            will create a git tag for the commit as results/parity/squids, and will create the
            folders "parity" and subfolder "squids" to store the results in.  It is an error
            to specify a tag that already exists.  "dated" is also an invalid option, as that is
            a unique folder created by git-results to help with indexing results by date.
            "latest" is invalid as well, referring to another unique folder."""))
    args = ap.parse_args(programArgs)

    if args.path:
        # Override dir and tag
        path = args.tag
        args.tag = ""
        while True:
            s = os.path.split(path)
            if s[0]:
                args.tag = os.path.join(s[1], args.tag)
                path = s[0]
            else:
                args.dir = s[1]
                args.tag = args.tag.strip('/')
                break
    checkTag(args.tag)
    args.dir = args.dir.rstrip('/')

    if not os.path.isfile('git-results-build'):
        print(textwrap.dedent("""
                To use git-results, two files are required: git-results-run and
                git-results-build.  Even if git-results-build is empty, it must exist.
                git-results-build should be a script that builds resources used by
                git-results-run."""))

    if not os.path.isfile('git-results-run'):
        print(textwrap.dedent("""
                To use git-results, you must have a git-results-run file in your
                repository's root.  This file must contain a single shell-executable
                line of text that runs your experiment."""))
        sys.exit(1)

    # OK, run the experiment
    resultsDirRun, datedLinkRun, latestLinkRun, commitTag = setupExperiment(
            args.dir, args.commit, args.tag, args.message)
    resultsDir = resultsDirRun[:-len(RUN_SUFFIX)]
    datedLink = datedLinkRun[:-len(RUN_SUFFIX)]
    latestLink = latestLinkRun[:-len(RUN_SUFFIX)]

    runFailed = False
    try:
        # NOTE - For e.g. MPI, or other network tasks, we do not use the
        # standard tempfile methods.  The path has to be accessible on all
        # machines.
        expDir = None
        if args.in_place:
            expDir = None
        else:
            safeMake(os.path.join(args.dir, ".tmp"))
            while True:
                randName = "".join([
                        random.choice("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")
                        for _ in range(8) ])
                expDir = os.path.join(args.dir, ".tmp", randName)
                try:
                    os.mkdir(expDir)
                    break
                except OSError, e:
                    # Already exists
                    if e.errno != 17:
                        raise
        try:
            r, abrt = runExperiment(expDir, resultsDirRun, commitTag, args.trim)
            if r != 0:
                runFailed = True
                if abrt:
                    runFailed = "abort"
        finally:
            if expDir is not None:
                shutil.rmtree(expDir)
                safeRollback(os.path.dirname(expDir))
    except:
        # Roll back our tag and results folders...
        traceback.print_exc()
        print("Deleting {} and associated tags / links".format(resultsDirRun))
        checked("git tag -d {}".format(commitTag))
        os.unlink(datedLinkRun)
        safeRollback(os.path.dirname(datedLinkRun))
        if os.path.abspath(os.path.join(os.path.dirname(latestLinkRun),
                oldLink)) == os.path.abspath(resultsDirRun):
            os.unlink(latestLinkRun)
            safeRollback(os.path.dirname(latestLinkRun))
        shutil.rmtree(resultsDirRun)
        safeRollback(os.path.dirname(resultsDirRun))
        # Build failed for sure!
        sys.exit(1)

    # Move the RUN_SUFFIX folder to the appropriate suffix
    newSuffix = ""
    if runFailed:
        # We failed, but not due to a build failure.
        # Move our numbered file to one like "3-fail"
        newSuffix = FAIL_SUFFIX
        if runFailed == "abort":
            newSuffix = ABORT_SUFFIX

    print("Moving {} to {}".format(resultsDirRun, resultsDir + newSuffix))
    os.rename(resultsDirRun, resultsDir + newSuffix)

    oldLink = os.readlink(datedLinkRun)
    os.unlink(datedLinkRun)
    os.symlink(oldLink[:-len(RUN_SUFFIX)] + newSuffix, datedLink + newSuffix)

    oldLink = os.readlink(latestLinkRun)
    if (os.path.abspath(os.path.join(os.path.dirname(latestLinkRun), oldLink))
            == os.path.abspath(resultsDirRun)):
        # We were the latest test, so do the update
        os.unlink(latestLinkRun)
        os.symlink(oldLink[:-len(RUN_SUFFIX)] + newSuffix,
                latestLink + newSuffix)

    if runFailed:
        sys.exit(1)


if __name__ == '__main__':
    run()
