#! /usr/bin/env python2

"""Created by Walt Woods, 2014"""

from __future__ import print_function

import argparse
import cPickle as pickle
import datetime
import inspect
import os
import random
import re
import shlex
import shutil
import subprocess
import sys
# Note on tempfile - only used for configuration, not for any execution.  This
# is so that if any of the git-results-* scripts invoke network file system
# activity, those files are accessible to all nodes with access to the NFS.
import tempfile
import textwrap
import threading
import time
import traceback

# For pickle, we're using git_results.* for class names.  So, shenanigans
__oname__ = __name__
class __dummy(object):
    pass
sys.modules['git_results'] = inspect.getmodule(__dummy)
__name__ = 'git_results'

ABORT_SUFFIX = '-abrt'
FAIL_SUFFIX = '-fail'
RUN_SUFFIX = '-run'
SUFFIXES = [ ABORT_SUFFIX, FAIL_SUFFIX, RUN_SUFFIX, '' ]
# Overridden by tests to suppress raw_input
IS_TEST = False

class IndexStates(object):
    ABORT = 'abrt'
    FAIL = 'fail'
    GONE = 'gone'
    OK = '  ok'


class FolderState(object):
    """An object that tracks which files exist at init and at another time,
    and can copy changes to another folder."""

    def __init__(self, dir, resultsDir):
        """If dir is None, then this is an in-place operation, and we should
        move (rather than copy) the results."""
        self._inPlace = (dir is None)
        self._dir = dir or os.path.abspath('.')
        self._resultsDirRel = os.path.relpath(resultsDir, self._dir)
        if not self._resultsDirRel.startswith(".."):
            while True:
                rdr = os.path.split(self._resultsDirRel)[0]
                if not rdr:
                    break
                self._resultsDirRel = rdr
        self._files = set()
        self._scan(self._dir)


    def moveResultsTo(self, dir, trimCommonPaths = False):
        """Copy changes from self._dir to dir.  Use most common path."""
        allChanges = set()
        self._scanChanges(self._dir, allChanges)

        prefix = None
        for c in allChanges:
            if prefix is None:
                prefix = c
            else:
                while not c.startswith(prefix):
                    prefix = os.path.dirname(prefix)

        for c in allChanges:
            # Add 1 to len(prefix) so that we don't include the preceding slash,
            # which would make os.path.join treat it as an absolute
            target = os.path.relpath(c, self._dir)
            if trimCommonPaths:
                target = os.path.relpath(c, prefix)
            target = os.path.join(dir, target)
            safeMake(os.path.dirname(target))
            try:
                os.rename(c, target)
            except OSError, e:
                if e.errno != 2:
                    # No such file; was temporary
                    raise


    def forgetPath(self, path):
        """Forget a path and all subpaths."""
        f = set()
        for p in self._files:
            if p.startswith(path):
                f.add(p)
        for p in f:
            self._files.remove(p)


    def _isBanned(self, path):
        if path == os.path.join(self._dir, self._resultsDirRel):
            return True
        return False


    def _scan(self, path):
        if self._isBanned(path):
            return
        for f in os.listdir(path):
            ff = os.path.join(path, f)
            if os.path.isfile(ff):
                self._files.add(ff)
            if os.path.isdir(ff) and not os.path.islink(ff):
                self._scan(ff)


    def _scanChanges(self, path, changeset):
        if self._isBanned(path):
            return
        for f in os.listdir(path):
            ff = os.path.join(path, f)
            if os.path.isfile(ff) and ff not in self._files:
                changeset.add(ff)
            elif os.path.isdir(ff) and not os.path.islink(ff):
                self._scanChanges(ff, changeset)



def checked(cmd, nonZeroOk = False, shell = False):
    cmd = shlex.split(cmd)
    p = subprocess.Popen(cmd, stdout = subprocess.PIPE,
            stderr = subprocess.PIPE, shell = shell)
    stdout, stderr = p.communicate()
    r = p.poll()

    if r != 0:
        if (isinstance(nonZeroOk, (list, tuple)) and r in nonZeroOk
                or nonZeroOk == True):
            pass
        else:
            raise Exception("Command '{0}' failed with {1}".format(cmd, r))
    return stdout


def copySymlinks(frm, to):
    """Copies all symlinks recursively from directory frm to directory to."""
    for f in os.listdir(frm):
        ffrm = os.path.join(frm, f)
        fto = os.path.join(to, f)
        if os.path.islink(ffrm):
            linkTo = os.readlink(ffrm)
            os.symlink(linkTo, fto)
        elif os.path.isdir(ffrm) and os.path.isdir(fto):
            copySymlinks(ffrm, fto)


def ensureGitignore(resultsDir):
    if not checked("git status {0}/.gitignore --porcelain --ignored".format(
            resultsDir)).startswith("!!"):
        with open('.gitignore', 'a') as f:
            f.write("\n/{0}".format(resultsDir))


def getPathForResumeKey(resumeKey, filename = None):
    base = os.path.expanduser("~/.gitresults")
    if resumeKey:
        base = os.path.join(base, resumeKey)
        if filename:
            base = os.path.join(base, filename)
    elif filename:
        raise Exception("filename but no resumeKey?")
    return base


def tee(infile, *files):
    """Thanks to http://stackoverflow.com/a/4985080/160205, tee lines from the
    given file to one or more other files.
    """
    def fanout():
        for line in iter(infile.readline, ''):
            for f in files:
                f.write(line)
        infile.close()
    t = threading.Thread(target = fanout)
    t.daemon = True
    t.start()
    return t


def touch(fname):
    """Thanks to http://stackoverflow.com/questions/1158076/implement-touch-using-python"""
    with open(fname, 'a'):
        os.utime(fname, None)


def updateIndex(commitTag, state):
    """Given a commitTag from git (with or without suffix) and a new index
    state, update the (xxxx) portion of the INDEX file to reflect the given
    state.
    """
    path, exp = commitTag.rsplit('/', 1)
    exp = exp.rsplit('-', 1)[0]
    with open(os.path.join(path, 'INDEX'), 'r+') as f:
        contents = f.read()
        lastMatch = None
        for m in re.finditer(r"^{} \(....\) - ".format(int(exp)),
                contents, re.MULTILINE):
            lastMatch = m
        if lastMatch is not None:
            f.seek(lastMatch.start())
            f.write("{} ({}) - ".format(int(exp), state))


def runExperiment(args, dir, extraFiles, resultsDir, commitTag,
        trimCommonPaths):
    """Given a directory to initialize and run our experiment in 'dir', run it
    and put results in 'resultsDir'

    Populates args.isGoingToRetry if args.retry_until_stall is set.

    dir can be None for current dir (not a temporary directory!)
    """

    # If False, this is a retry that has already been built.
    shouldBuild = True
    # Folder state post-build; used to identify run results vs build
    # intermediates
    fs = None
    if args.retry_until_stall:
        # Set this attribute so that we have access to it
        args.isGoingToRetry = False
        if os.path.lexists(getPathForResumeKey(args.retryKey, "build-state")):
            shouldBuild = False

        def writeRetryStats():
            """Write a bunch of stats from our closure"""
            open(getPathForResumeKey(args.retryKey, "build-state.new"),
                    'w').write(pickle.dumps({
                        'buildTime': preRun - preBuild,
                        'runStart': preRun,
                        'fs': fs,
                        'progress': lastProgress,
                        'retry': retryIndex }))
            os.rename(getPathForResumeKey(args.retryKey, "build-state.new"),
                    getPathForResumeKey(args.retryKey, "build-state"))

    if dir is None:
        dirRelative = '.'
    else:
        dirRelative = dir
        dir = os.path.abspath(dir)
    resultsDirRelative = resultsDir
    resultsDir = os.path.abspath(resultsDir)
    odir = os.getcwd()
    if dir is not None:
        os.chdir(dir)
    try:
        # Timers
        preBuild = preRun = None
        # Keeps track of last known completed progress _at the start_ of an
        # execution.
        # Used to determine stalls (intransient errors).  Updated at end of
        # execution (on failure) if there was a change in progress since the
        # last update.
        lastProgress = -1e300
        # The current retry index.
        retryIndex = 0
        if shouldBuild:
            buildHeartbeatStop = False
            buildHeartbeat = None
            if args.retry_until_stall:
                def hbUpdate():
                    tsleep = args.retry_delay / 3.0
                    touch(getPathForResumeKey(args.retryKey, "heartbeat"))
                    while not buildHeartbeatStop:
                        time.sleep(tsleep)
                        touch(getPathForResumeKey(args.retryKey, "heartbeat"))
                buildHeartbeat = threading.Thread(target = hbUpdate)
                buildHeartbeat.daemon = True
                buildHeartbeat.start()

            # Build not previously completed, rebuild project
            if dir is not None:
                checked('git init')
                checked('git remote add origin file://{0}'.format(odir))
                checked('git fetch origin {0}'.format(commitTag))
                checked('git reset --hard FETCH_HEAD')
                copySymlinks(odir, dir)
                for grFile in [ "git-results-build", "git-results-run",
                        "git-results-progress" ]:
                    if os.path.lexists(os.path.join(odir, grFile)):
                        shutil.copy2(os.path.join(odir, grFile), os.path.join(
                                dir, grFile))

            # Copy supplementary (extra) files over to our tree before build
            for f in extraFiles:
                fFrm, fTo = f.split(':')
                shutil.copy2(os.path.join(odir, fFrm), os.path.join(dir, fTo))

            preBuild = time.time()

            print("Building {0} in {1}".format(commitTag, dirRelative))
            # stderr redirection benefits nosetests, mainly.
            p = subprocess.Popen(os.path.abspath('./git-results-build'),
                    shell = True,
                    stdout = subprocess.PIPE,
                    stderr = subprocess.STDOUT)
            thread = tee(p.stdout, sys.stdout)
            thread.join()
            r = p.wait()
            if r != 0:
                print("== BUILD FAILED ==")
                sys.exit(1)

            # Now that we've built it, snapshot the folder so we can copy whatever
            # changed as results.  We'll be a little smart and take off the
            # greatest common path too...
            fs = FolderState(dir, resultsDir)
            for f in extraFiles:
                _, fTo = f.split(':')
                fs.forgetPath(os.path.join(os.path.join(dir, fTo)))

            # Actual run starts now..ish.  Yes, this doesn't include scanning
            # the folder state.  However, for a retry, we want to remember both
            # how long the build took and the cumulative runtime.
            preRun = time.time()

            if args.retry_until_stall:
                buildHeartbeatStop = True
                buildHeartbeat.join()

                # Save fs so that we know that we've already built
                writeRetryStats()
                touch(getPathForResumeKey(args.retryKey, "heartbeat"))
        else:
            # Previously built OK, use old values
            try:
                d = pickle.loads(open(getPathForResumeKey(args.retryKey,
                        "build-state")).read())
            except pickle.UnpicklingError:
                # Corrupt test; mark as failed, append to stderr!
                with open('{0}/stderr'.format(resultsDir), 'a') as f:
                    f.write("\n\ngit-results detected bad formatting for "
                            "pickle file build-state; copied to result "
                            "directory and marking experiment failed")
                    return 1, False
            fs = d['fs']
            preRun = time.time() - (os.path.getmtime(getPathForResumeKey(
                    args.retryKey, "heartbeat")) - d['runStart'])
            preBuild = preRun - d['buildTime']
            lastProgress = d['progress']
            retryIndex = d['retry']
            touch(getPathForResumeKey(args.retryKey, "heartbeat"))


        hasProgress = os.path.lexists('./git-results-progress')
        print("Running {0} in {1}".format(commitTag, dirRelative))
        print("=" * 79)
        print("=" * 79)

        threadsShouldDie = False
        threads = []

        if hasProgress:
            def checkProgress():
                """Returns the monotonically increasing, floating-point number
                that denotes progress.  If retry_until_stall is set, also
                updates the progress file associated with the retry."""
                cmd = os.path.abspath('./git-results-progress')
                p = subprocess.Popen(cmd, shell = True,
                        stdout = subprocess.PIPE,
                        stderr = subprocess.PIPE)
                stdout, stderr = p.communicate()
                r = p.wait()
                try:
                    value = float(stdout.strip().split('\n')[-1])
                except ValueError:
                    raise ValueError(("Last non-blank line must be a "
                            + "floating-point number; was: {}").format(
                                stdout.strip().split('\n')[-1]))
                return value
        if args.retry_until_stall:
            # Update heartbeats
            def hbUpdate():
                tsleep = args.retry_delay / 3.0
                while not threadsShouldDie:
                    time.sleep(tsleep)
                    touch(getPathForResumeKey(args.retryKey, "heartbeat"))
            hbThread = threading.Thread(target = hbUpdate)
            hbThread.daemon = True
            hbThread.start()
            threads.append(hbThread)

        iothreads = []
        didAbort = False
        try:
            # Special handling for our runner script
            line_buffered = 1
            output = open('{0}/stdout'.format(resultsDir), 'a', line_buffered)
            error = open('{0}/stderr'.format(resultsDir), 'a', line_buffered)
            p = subprocess.Popen(os.path.abspath('./git-results-run'),
                    shell = True, stdout = subprocess.PIPE,
                    stderr = subprocess.PIPE)
            iothreads = [ tee(p.stdout, output, sys.stdout),
                    tee(p.stderr, error, sys.stderr) ]
            [ t.join() for t in iothreads ]
            r = p.wait()
        except KeyboardInterrupt:
            # Child got Ctrl+C,
            print("== CTRL+C caught by git-results; child should exit as per "
                    "CTRL+C semantics")
            [ t.join() for t in iothreads ]
            r = p.wait()
            didAbort = True

        allDone = time.time()
        print("=" * 79)
        print("=" * 79)

        if r != 0:
            error.write(("\n\ngit-results detected abnormal program "
                    "termination: {0}\n").format(r))
            print("Non-zero exit status after {0}: {1}".format(allDone - preRun,
                    r))

            if args.retry_until_stall and not didAbort:
                # Chance of supervisor retry...
                if not hasProgress:
                    raise Exception("No git-results-progress but "
                            "retry_until_stall?")
                newProgress = checkProgress()
                if lastProgress > newProgress:
                    raise Exception("Progress MUST be a non-decreasing "
                            + "function")
                elif lastProgress == newProgress:
                    # Stall; note that the FIRST potentially transient failure
                    # will happen with lastProgress != newProgress, so if
                    # retryIndex was 0, this is technically the first retry
                    retryIndex += 1
                    if args.retry_minimum > retryIndex:
                        args.isGoingToRetry = True
                        writeRetryStats()
                    else:
                        # Cannot retry!
                        pass
                else:
                    # Progress!
                    lastProgress = newProgress
                    retryIndex = 0
                    args.isGoingToRetry = True
                    writeRetryStats()
        else:
            print("OK after {0}".format(allDone - preRun))

        if not args.retry_until_stall or not args.isGoingToRetry:
            # If we reach here, everything ran OK, so copy files
            print("Copying results to {0}".format(resultsDirRelative))
            fs.moveResultsTo(resultsDir, trimCommonPaths)

            with open(os.path.join(resultsDir, 'git-results-message'), 'a') as f:
                f.write("\n\n")
                f.write("{0} after {1}s\n".format("OK" if r == 0 else "FAIL",
                        allDone - preRun))
                f.write("Build took {0}s\n".format(preRun - preBuild))

        # Terminate e.g. heartbeat thread
        threadsShouldDie = True
        [ t.join() for t in threads ]

        return r, didAbort
    finally:
        os.chdir(odir)


def safeMake(path):
    try:
        os.makedirs(path)
    except OSError, e:
        # exists
        if e.errno != 17:
            raise


def setupExperiment(resultsDir, shouldCommit, tag, message):
    """Sets up the experiment skeleton and commits the git repo to an acceptable
    state.

    If message is unspecified, will prompt for a suitable message.

    Returns the directory for results (absolute path), dated symlink path (for
    rollback / updated), latest symlink path, and the commit tag to run.
    """
    resultsBaseRelative = resultsDir
    resultsDir = os.path.abspath(resultsDir)
    if not os.path.lexists(os.path.join(resultsDir, ".git")):
        curdir = os.getcwd()
        safeMake(resultsDir)
        os.chdir(resultsDir)
        checked("git init")
        os.chdir(curdir)

    if not os.path.lexists("{0}/.gitignore".format(resultsDir)):
        # If we don't make a file, it looks like results is always ignored even
        # though it isn't.  Luckily, we need a .gitignore anyway
        with open("{0}/.gitignore".format(resultsDir), 'w') as f:
            f.write("/.tmp\n")

    # Now that it's made, make sure it's ignored
    ensureGitignore(resultsBaseRelative)

    # Allow / encourage running same tag several times.  We'll use /1, /2, etc
    n = 1
    if os.path.lexists(os.path.join(resultsBaseRelative, tag)):
        for run in os.listdir(os.path.join(resultsBaseRelative, tag)):
            # Remove any suffixes
            run = run.split('-', 1)[0]
            try:
                n = max(n, int(run) + 1)
            except ValueError:
                # Not an integer, probably a file someone bundled in with the
                # results.
                pass
    pureTag = tag
    tagDir = os.path.join(resultsBaseRelative, tag + "/{0}".format(n))
    tag = tag + "/{0}".format(n)
    gitTag = "{0}/{1}".format(resultsBaseRelative, tag)

    if message:
        cleanMessage = _escapeString(message)
    else:
        message = _getStringViaEditor("git-results needs a commit message")
        if len(message) < 5 or message.startswith("Please replace"):
            raise ValueError("Commit message must be at least 5 "
                    "characters; got: '" + message + "'")
        cleanMessage = _escapeString(message)

    # Check the state of our git repo
    if checked("git status --porcelain").strip():
        # Need to commit, if we can
        if not shouldCommit:
            sys.stderr.write("Repository has unsaved changes; use -c to commit "
                    "automatically.\n")
            sys.exit(1)

        # Make sure git-results-build and git-results-run are ignored
        gb = checked("git status git-results-build --porcelain --ignored")
        if gb and not gb.startswith("!!"):
            # Would be added.  Don't do that!
            with open(".gitignore", "a") as f:
                f.write("\n/git-results-build")
        gb = checked("git status git-results-run --porcelain --ignored")
        if gb and not gb.startswith("!!"):
            # Same
            with open(".gitignore", "a") as f:
                f.write("\n/git-results-run")
        gb = checked("git status git-results-progress --porcelain --ignored")
        if gb and not gb.startswith("!!"):
            # Same
            with open(".gitignore", "a") as f:
                f.write("\n/git-results-progress")

        # If this fails, the branch didn't exist or we're already on it, both
        # of which are fine
        checked("git checkout -B git-results")
        checked("git add -A .")
        checked('git commit -m "{0}"'.format(cleanMessage))

    curCommit = checked("git rev-parse HEAD").strip()

    # Actually make our folder
    tagDirRun = tagDir + RUN_SUFFIX
    safeMake(tagDirRun)

    # Ensure INDEX file
    with open(os.path.join(resultsDir, pureTag, 'INDEX'), 'a') as f:
        header = "{} ( run) - ".format(n)
        wrapper = textwrap.TextWrapper(width = 79, initial_indent = '',
                subsequent_indent = '  ')
        f.write(wrapper.fill(header + message))
        f.write('\n')

    # Dated linkage
    now = datetime.datetime.now()
    dated = os.path.join(resultsDir, 'dated', now.strftime("%Y"),
            now.strftime("%m"))
    safeMake(dated)

    linkAs = os.path.join(dated, "{0}-{1}{2}".format(now.strftime("%d"), tag,
            RUN_SUFFIX))
    safeMake(os.path.dirname(linkAs))
    parentLevel = 2 + len(tag.split('/'))
    os.symlink(os.path.relpath(tagDirRun, os.path.dirname(linkAs)), linkAs)

    latestLinkAs = os.path.join(resultsDir, 'latest', pureTag + RUN_SUFFIX)
    safeMake(os.path.dirname(latestLinkAs))
    for s in SUFFIXES:
        linkPath = os.path.join(resultsDir, 'latest', pureTag + s)
        if os.path.lexists(linkPath):
            os.unlink(linkPath)
    os.symlink(os.path.relpath(tagDirRun, os.path.dirname(latestLinkAs)),
            latestLinkAs)

    # Add our tag to the git repo
    checked('git tag -a -m "{0}" {1}'.format(cleanMessage, gitTag))

    # Write our message file
    with open(os.path.join(tagDirRun, "git-results-message"), "w") as f:
        f.write("{0}\n{1}\n".format(gitTag, "=" * min(79, len(gitTag))))
        if message:
            f.write("{0}\n".format(message))
        f.write("\nCommit: {0}".format(curCommit))
        f.write("\n\ngit-results-run\n---------------\n")
        f.write(open('git-results-run').read())
        f.write("\n\ngit-results-build\n-----------------\n")
        f.write(open('git-results-build').read())
        if os.path.lexists('git-results-progress'):
            f.write("\n\ngit-results-progress\n-----------------\n")
            f.write(open('git-results-progress').read())
        f.write("\n\nStarted {0}".format(now.strftime("%Y-%m-%dT%H:%M:%S")))

    return tagDirRun, linkAs, latestLinkAs, gitTag


def checkTag(s):
    """Takes a string s and returns it, if it is a tag."""
    if re.search("^[a-zA-Z0-9_/\.-]+$", s) is None:
        raise ValueError("Tag must match regex [a-zA-Z0-9_/\.-]+")
    if s.startswith('dated'):
        raise ValueError("Tag may not start with 'dated'")
    if s.startswith('latest'):
        raise ValueError("Tag may not start with 'latest'")
    if s.strip('/') != s:
        raise ValueError("Tag may not begin or end with '/'")
    isInt = False
    try:
        int(s.split('/')[-1])
        isInt = True
    except ValueError:
        pass
    if isInt:
        raise ValueError("Tag may not end in a number")
    return s


def safeRollback(d):
    """Delete d and all parent directories (up to most common directory with
    current directory)
    """
    try:
        os.removedirs(d)
    except OSError, e:
        # Directory not empty OR no such file or directory
        if e.errno != 39 and e.errno != 2:
            raise


def _checkGit():
    """Raises Exception if cwd does not have a .git folder"""
    if not os.path.isdir('.git'):
        print("Must be used in a git directory!")
        sys.exit(1)


def _escapeString(st):
    """Returns st escaped so it can be used as a string within the shell"""
    return st.replace('"', '\\"').replace("&", "\\&"
            ).replace("|", "\\|").replace("!", "\\!")


def _getStringViaEditor(prompt = ""):
    """Gets a string by popping up an editor in the CLI; optionally presents
    a reason."""
    baseEditor = os.environ.get("VISUAL") or os.environ.get("EDITOR") or "vi"
    # Note that git config returns 1 if key not found
    gitEditor = checked("git config --get core.editor", nonZeroOk = [ 1 ]
            ).strip()
    editor = gitEditor or baseEditor

    (fd, name) = tempfile.mkstemp(prefix="git-results-", suffix=".txt",
            text = True)
    try:
        f = os.fdopen(fd, "wt")
        # f.write(contents)
        f.close()

        if prompt and not IS_TEST:
            raw_input(prompt + ".  Press enter to continue.")

        r = os.system('{} "{}"'.format(editor, name))
        if r != 0 and r != 1:
            raise Exception('Editor failed: {} "{}"'.format(editor, name))

        with open(name) as f:
            return f.read().strip()
    finally:
        os.unlink(name)


def _processTagArgs(args, pathArg, dirArg, *tagArgs):
    """Sort out -d and -p args with arbitrary number of tags.  args.dir is
    populated with a list of directories corresponding with tags, in order.

    Also responsible for default dir of "results"
    """
    if getattr(args, pathArg, None) and getattr(args, dirArg, None):
        raise ArgumentError("-d and -p are incompatible")

    oldDir = (getattr(args, dirArg) or "results").rstrip()
    newDirs = []

    for tagArg in tagArgs:
        tag = getattr(args, tagArg)
        if getattr(args, pathArg):
            # Override dir and tag values given -p
            path = tag
            tag = ""
            while True:
                s = os.path.split(path)
                if s[0]:
                    if tag:
                        tag = '/'.join([ s[1], tag ])
                    else:
                        tag = s[1]
                    path = s[0]
                else:
                    newDirs.append(s[1])
                    tag = tag.strip('/')
                    break
        else:
            newDirs.append(oldDir)
        checkTag(tag)
        setattr(args, tagArg, tag)

    setattr(args, dirArg, newDirs)


def _auditMove(pathFrom, pathTo):
    """Audits that the given matchingTags can be moved from pathFrom to pathTo
    without collisions.

    Returns matchingTags - tagSrc, tagDst, dirSrc, dirDest, suffix.  Suffix
    includes hyphen.  dirSrc and dirDest are highest ancestor and may be
    redundant between several results.  tagSrc and tagDest are unique, and are
    the actual numbered runs.
    """
    gitTags = [ t.strip() for t in checked(
            "git tag -l '{0}' '{0}/*'".format(pathFrom)).strip().split('\n') ]
    matchingTags = []
    for src in gitTags:
        if not src.startswith(pathFrom):
            raise ValueError("Tag {0} doesn't start with {1}".format(src,
                    pathFrom))
        dest = pathTo + src[len(pathFrom):]
        # Check that the source folder exists, not just the tag in git
        suffix = None
        for s in SUFFIXES:
            if os.path.lexists(src + s):
                if s == "-run":
                    sys.stderr.write("Cannot move/link tag that is running: {0}"
                            .format(src))
                    sys.exit(1)
                suffix = s
                break

        if suffix is None:
            sys.stderr.write("Cannot find data for {0}".format(src))
        matchingTags.append(( src, dest, pathFrom, pathTo, suffix ))

        # Check that the destination doesn't exist
        existingForms = []
        if checked("git tag -l '{0}'".format(dest)).strip():
            existingForms.append("tag")
        for s in SUFFIXES:
            if os.path.lexists(dest + s):
                existingForms.append("filesystem" + s)
        if existingForms:
            sys.stderr.write("Destination tag {0} exists ({1})".format(
                    dest, ', '.join(existingForms)))
            sys.exit(1)

    return matchingTags


class LatestTracker(object):
    def __init__(self):
        """Keeps track of moved stuff, sorts out which should be the new latest
        link, does the update."""
        self._entries = {}


    def addTagDir(self, srcDir, tagDir, suffix):
        results, path = tagDir.split('/', 1)
        tagLatest, tagNumber = (results + '/latest/' + path).rsplit('/', 1)

        results, path = srcDir.split('/', 1)
        srcLatest, srcNumber = (results + '/latest/' + path).rsplit('/', 1)

        number = int(tagNumber.split('-')[0])
        if tagLatest in self._entries:
            if number > self._entries[tagLatest][0]:
                self._entries[tagLatest] = (number, suffix, tagDir, srcLatest)
        else:
            self._entries[tagLatest] = (number, suffix, tagDir, srcLatest)


    def commit(self, deleteOldLatest = False):
        """Make new latest symlinks"""
        # Update latest; each matchingTag's last part is the trial number, and
        # we should link the highest
        for path, (number, suffix, target, srcLatest
                ) in self._entries.iteritems():
            safeMake(os.path.dirname(path + suffix))
            os.symlink(os.path.relpath(target, os.path.dirname(path)),
                    path + suffix)
            if deleteOldLatest:
                # srcLatest + suffix must be it, but it may not exist due to
                # e.g. old version of code.  Best be safe
                for s in SUFFIXES:
                    if os.path.lexists(srcLatest + s):
                        os.unlink(srcLatest + s)


def _runLink(args):
    ap = argparse.ArgumentParser(description = "Link one or more tagged "
            "results to a new location (which refers to the original).")
    ap.add_argument("-p", "--path", action = 'store_true', help = "Same as -p "
            "for normal git results calls; means that the paths specified "
            "include the results directory as the first element.  Supercedes "
            "-d.  Must match for both paths given.")
    ap.add_argument("-d", "--dir", help = "Directory used to store results.")
    ap.add_argument("tag_from")
    ap.add_argument("tag_to")
    args = ap.parse_args(args)
    _processTagArgs(args, "path", "dir", "tag_from", "tag_to")
    pathFrom = '/'.join([ args.dir[0], args.tag_from ])
    pathTo = '/'.join([ args.dir[1], args.tag_to ])

    matchingTags = _auditMove(pathFrom, pathTo)

    # Do the links
    latestTracker = LatestTracker()
    for tagSrc, tagDest, _dirSrc, _dirDest, suffix in matchingTags:
        dirSrc = tagSrc + suffix
        dirDest = tagDest + suffix
        safeMake(os.path.dirname(dirDest))
        os.symlink(os.path.relpath(dirSrc, os.path.dirname(dirDest)), dirDest)
        tagMsg = checked("git tag -l -n1000 {0}".format(tagSrc)).strip()[
                len(tagSrc):].strip()
        checked("git tag -a -m '{0}' {1} {2}".format(tagMsg.replace("'", "\'"),
                tagDest, tagSrc))
        latestTracker.addTagDir(dirSrc, dirDest, suffix)
    latestTracker.commit()


def _runMove(args):
    ap = argparse.ArgumentParser(description = "Move one or more tagged "
            "results to a different tag.")
    ap.add_argument("-p", "--path", action = 'store_true', help = "Same as -p "
            "for normal git results calls; means that the paths specified "
            "include the results directory as the first element.  Supercedes "
            "-d.  Must match for both paths given.")
    ap.add_argument("-d", "--dir", help = "Directory used to store results.")
    ap.add_argument("tag_from")
    ap.add_argument("tag_to")
    args = ap.parse_args(args)
    _processTagArgs(args, "path", "dir", "tag_from", "tag_to")
    pathFrom = '/'.join([ args.dir[0], args.tag_from ])
    pathTo = '/'.join([ args.dir[1], args.tag_to ])

    matchingTags = _auditMove(pathFrom, pathTo)

    # tag path : [ Y, M, D ]
    tagDates = {}
    def walkDateDir(path, tag, dateInfo):
        if os.path.islink(path):
            # Strip off the fail / success / whatever status
            if '-' in tag.rsplit('/', 1)[1]:
                tag = tag.rsplit('-', 1)[0]
            tagDates[tag] = dateInfo
        elif os.path.isdir(path):
            for p in os.listdir(path):
                walkDateDir(os.path.join(path, p), '/'.join([ tag, p ]),
                        dateInfo)

    dateBase = os.path.join(args.dir[0], 'dated')
    for year in os.listdir(dateBase):
        yearBase = os.path.join(dateBase, year)
        for month in os.listdir(yearBase):
            monthBase = os.path.join(yearBase, month)
            for dayHyphen in os.listdir(monthBase):
                day, tagStart = dayHyphen.split('-', 1)
                walkDateDir(os.path.join(monthBase, dayHyphen),
                        '/'.join([ args.dir[0], tagStart ]),
                        [ year, month, day ])

    # Everything seems OK, rename it all.  Start with all of the filesystem
    # changes since we can run git results resync (once implemented) afterwards.
    latestTracker = LatestTracker()
    for tagSrc, tagDest, dirSrc, dirDest, suffix in matchingTags:
        if os.path.lexists(dirSrc):
            # This one hasn't been moved yet
            safeMake(os.path.dirname(dirDest))
            os.rename(dirSrc, dirDest)
            safeRollback(os.path.dirname(dirSrc))
        tagMsg = checked("git tag -l -n1000 {0}".format(tagSrc)).strip()[
                len(tagSrc):].strip()
        checked("git tag -a -m '{0}' {1} {2}".format(tagMsg.replace("'", "\'"),
                tagDest, tagSrc))
        checked("git tag -d {0}".format(tagSrc))
        latestTracker.addTagDir(tagSrc + suffix, tagDest + suffix, suffix)

        # We have to update any dated links...
        dateInfo = tagDates.get(tagSrc)
        if dateInfo:
            tagDirDest = tagDest + suffix
            sansResultDir = (tagSrc + suffix).split('/', 1)[1]
            oldLink = os.path.join(args.dir[0], 'dated', dateInfo[0],
                    dateInfo[1], dateInfo[2] + '-' + sansResultDir)
            os.unlink(oldLink)
            safeRollback(os.path.dirname(oldLink))
            targLink = os.path.join(args.dir[1], 'dated', dateInfo[0],
                    dateInfo[1], dateInfo[2] + '-'
                    + tagDirDest.split('/', 1)[1])
            safeMake(os.path.dirname(targLink))
            os.symlink(os.path.relpath(tagDirDest, os.path.dirname(targLink)),
                    targLink)
    latestTracker.commit(True)


def _runSupervisor(args):
    """Runs the supervisor functionality.  That is, restarts any processes that
    have not updated their heartbeats in awhile."""
    ap = argparse.ArgumentParser("Designed to be put in crontab (or some other "
            "scheduler).  Retries experiments started with --retry-until-stall "
            "or -r if they are no longer running.")
    args = ap.parse_args(args)
    retryDir = os.path.expanduser("~/.gitresults")

    exps = os.path.lexists(retryDir) and os.listdir(retryDir) or []

    now = time.time()
    startedCount = 0
    # Used for tests
    allStarted = []
    for retryKey in exps:
        isTestKey = retryKey.startswith("rtest")
        if isTestKey and not IS_TEST or not isTestKey and IS_TEST:
            continue

        if not os.path.lexists(getPathForResumeKey(retryKey, "settings")):
            # OK, the settings file doesn't even exist.  If it still doesn't in
            # a second (it is created RIGHT after the folder), then remove this
            # experiment.
            time.sleep(1.0)
            if not os.path.lexists(getPathForResumeKey(retryKey, "settings")):
                print("Deleting experiment {}, failed to reach settings".format(
                        retryKey))
                shutil.rmtree(getPathForResumeKey(retryKey))
                continue

        # If we reach here, there are settings to be checked and respected
        try:
            expArgs = pickle.loads(open(getPathForResumeKey(retryKey, "settings"))
                    .read())
        except pickle.UnpicklingError:
            print("Corrupt experiment {}, unpickle of settings failed".format(
                    retryKey))
            continue
        expMtime = os.path.getmtime(getPathForResumeKey(retryKey, "settings"))
        if os.path.lexists(getPathForResumeKey(retryKey, "heartbeat")):
            expMtime = os.path.getmtime(getPathForResumeKey(retryKey,
                    "heartbeat"))

        if now - expMtime > expArgs.retry_delay:
            # Launch it!
            print("Resuming experiment {}".format(retryKey))
            startedCount += 1
            p = subprocess.Popen(shlex.split(
                    "git results --internal-retry-continue {}".format(
                        retryKey)), stdout = subprocess.PIPE,
                    stderr = subprocess.PIPE)
            # Note - the ONLY reason that we tee these threads is so that
            # nosetests will capture their output.
            iothreads = [ tee(p.stdout, sys.stdout),
                    tee(p.stderr, sys.stderr) ]
            allStarted.append(p)
    print("Supervisor finished; {} '-r' experiments restarted".format(
            startedCount))
    return allStarted


def run(programArgs = None):
    """Wraps _run, which does the work, so that the cwd is preserved.  Used for
    tests."""
    odir = os.getcwd()
    try:
        return _run(programArgs)
    finally:
        os.chdir(odir)


def _run(programArgs):
    if programArgs is None:
        programArgs = sys.argv[1:]

    if programArgs[0] == "move":
        _checkGit()
        return _runMove(programArgs[1:])
    elif programArgs[0] == "link":
        _checkGit()
        return _runLink(programArgs[1:])
    elif programArgs[0] == "supervisor":
        return _runSupervisor(programArgs[1:])

    ap = argparse.ArgumentParser(description = "A git extension for cataloging "
            "computation results.  Subcommands available: move, link, "
            "supervisor (e.g. git results move -h)")
    ap.add_argument("-d", "--dir", help = "Directory used "
            "to store results.  Automatically created and set up as a git "
            "repo.  Also automatically added to .gitignore")
    ap.add_argument("-p", "--path", action = 'store_true',
            help = "Supercedes -d and normal default tag argument.  The first "
                "path element in the tag argument becomes the results "
                "directory, and the rest becomes the tag.  Useful for e.g. "
                "tab completion in a console.")
    ap.add_argument("-i", "--in-place", action = 'store_true',
            help = "Do the build in place.  If you use this, you can't run "
                "several simultaneous git results calls on the same repo.  "
                "Recommended when you're trying to get a build working, or "
                "testing short experiments, but not otherwise.")
    ap.add_argument("-c", "--commit", action = 'store_true',
            help = "If there are uncommitted changes, automatically commit "
                "with the message as given.")
    ap.add_argument("-x", "--extra-file", action = 'append', default = [],
            help = "Of form path1:path2, where path1 is relative or absolute "
                "to the current working directory, and path2 is relative to "
                "the execution root where git-results-run is called.  Copies "
                "file path1 into path2 before running git-results-build and "
                "git-results-run.  Note that the extra file will be included "
                "as a \"result\".  That is, retained after the experiment "
                "completes.  --extra-file can be specified multiple times.")
    ap.add_argument("-t", "--trim", action = 'store_true',
            help = "Trim output paths to most common denominator.  That is, if "
                "the application creates folder results/a.txt, then since the "
                "results/ path is part of all created files, it will be "
                "trimmed (leaving just a.txt).")
    ap.add_argument("-m", "--message", help = "Commit message / "
            "git-results-message content paired with results.  If unspecified, "
            "we'll pop open an editor for you (like git commit)")
    ap.add_argument("-f", "--follow-cmd", help = "Shell command to run in the "
            "results directory on successful completion.  Useful for e.g. "
            "opening generated images when you don't want to put this in "
            "git-results-run")
    ap.add_argument("-r", "--retry-until-stall", action = 'store_true',
            help = "Registers the experiment with git-results supervisor, which "
            "will automatically retry the experiment until it succeeds or an "
            "error appears intransient.  Requires git-results-progress script, "
            "which calculates and produces output ending with a single line with only a floating-point "
            "number that is expected to keep increasing as progress happens (it should never decrease).  "
            "Any lines except for the final line will overwrite /progress in the "
            "experiment folder.  Pairs with --retry-minimum and --retry-delay to "
            "determine how many times a transient failure without progress will "
            "be retried, and what the delay between trials is.")
    ap.add_argument("--retry-minimum", type = int, default = 3, help = "Number of "
            "times to retry a transient failure (see --retry-until-stall)")
    def checkDelay(x):
        v = float(x)
        if v < 10.0 and not IS_TEST:
            raise ValueError("--retry-delay must be >= 10: {}".format(v))
        return v
    ap.add_argument("--retry-delay", type = checkDelay, default = 20,
            help = "Seconds between retries (see --retry-until-stall).  Must "
                "be >= 10")
    ap.add_argument("--internal-retry-continue", action = 'store_true',
            help = "Used by supervisor, resumes a previously aborted experiment.  "
            "Uses the corresponding values saved in ~/.gitresults/[tagKey]/settings")
    ap.add_argument("tag", help = textwrap.dedent("""
            Path to organize these results under.  For instance, giving a tag of parity/squids
            will create a git tag for the commit as results/parity/squids, and will create the
            folders "parity" and subfolder "squids" to store the results in.  It is an error
            to specify a tag that already exists.  "dated" is also an invalid option, as that is
            a unique folder created by git-results to help with indexing results by date.
            "latest" is invalid as well, referring to another unique folder."""))
    args = ap.parse_args(programArgs)

    if args.internal_retry_continue:
        # args.tag is our key for resuming a paused experiment.
        args = pickle.loads(open(getPathForResumeKey(args.tag, "settings"))
                .read())
    else:
        # Starting a new experiment
        _checkGit()
        args.cwd = os.getcwd()
        _processTagArgs(args, "path", "dir", "tag")
        # _processTagArgs sets args.dir to a list of directories.  For the main
        # functionality, we only have one dir.
        args.dir = args.dir[0]

        if args.retry_until_stall:
            if not os.path.isfile('git-results-progress'):
                print(textwrap.dedent("""
                        To use git-results with the -r or --retry-until-stall flag, you must have
                        a file named git-results-progress in your repository's root.  This file
                        can output anything, but the final line of output must contain only a floating
                        point number, which monotonically increases as work progresses."""))
                sys.exit(1)

            LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
            header = "r"
            if IS_TEST:
                header = "rtest"
            while True:
                retryKey = header + ''.join([ random.choice(LETTERS)
                        for _ in range(8) ])
                try:
                    os.makedirs(getPathForResumeKey(retryKey))
                    break
                except OSError, e:
                    if e.errno != 17:
                        # Folder already exists
                        raise
            args.retryKey = retryKey
            with open(getPathForResumeKey(retryKey, "settings"), 'w') as f:
                f.write(pickle.dumps(args))

    # Ensure we're in the right folder
    os.chdir(args.cwd)
    if not os.path.isfile('git-results-build'):
        print(textwrap.dedent("""
                To use git-results, two files are required: git-results-run and
                git-results-build.  Even if git-results-build is empty, it must exist.
                git-results-build should be a script that builds resources used by
                git-results-run."""))
        sys.exit(1)

    if not os.path.isfile('git-results-run'):
        print(textwrap.dedent("""
                To use git-results, you must have a git-results-run file in your
                repository's root.  This file must contain a single shell-executable
                line of text that runs your experiment."""))
        sys.exit(1)

    if not hasattr(args, 'setupInfo'):
        # Set up the experiment
        resultsDirRun, datedLinkRun, latestLinkRun, commitTag = setupExperiment(
                args.dir, args.commit, args.tag, args.message)
        if args.retry_until_stall:
            args.setupInfo = [ resultsDirRun, datedLinkRun, latestLinkRun,
                    commitTag ]
            with open(getPathForResumeKey(args.retryKey, "settings.new"), 'w') as f:
                f.write(pickle.dumps(args))
            os.rename(getPathForResumeKey(args.retryKey, "settings.new"),
                    getPathForResumeKey(args.retryKey, "settings"))
            with open(os.path.join(resultsDirRun, "git-results-retry-key"), 'w') as f:
                f.write(args.retryKey)
    else:
        resultsDirRun, datedLinkRun, latestLinkRun, commitTag = args.setupInfo

    resultsDir = resultsDirRun[:-len(RUN_SUFFIX)]
    datedLink = datedLinkRun[:-len(RUN_SUFFIX)]
    latestLink = latestLinkRun[:-len(RUN_SUFFIX)]

    runFailed = False
    runWillRetry = False
    try:
        # NOTE - For e.g. MPI, or other network tasks, we do not use the
        # standard tempfile methods.  The path has to be accessible on all
        # machines.
        expDir = None
        if args.in_place:
            expDir = None
        else:
            safeMake(os.path.join(args.dir, ".tmp"))
            if args.retry_until_stall:
                # Use the retry key as the temporary folder
                expDir = os.path.join(args.dir, ".tmp", args.retryKey)
                try:
                    # Make the dir, if it already exists that's OK
                    os.mkdir(expDir)
                except OSError, e:
                    if e.errno != 17:
                        raise
            else:
                # We need a temporary folder
                while True:
                    randName = "".join([
                            random.choice("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")
                            for _ in range(8) ])
                    expDir = os.path.join(args.dir, ".tmp", randName)
                    try:
                        os.mkdir(expDir)
                        break
                    except OSError, e:
                        # Already exists
                        if e.errno != 17:
                            raise

        # Link expDir into git-results-tmp
        tmpDirLink = os.path.join(resultsDirRun, 'git-results-tmp')
        try:
            os.symlink(os.path.abspath(expDir or '.'), tmpDirLink)
        except OSError, e:
            # Already exists
            if e.errno != 17:
                raise

        try:
            r, abrt = runExperiment(args, expDir, args.extra_file,
                    resultsDirRun, commitTag, args.trim)
            if r != 0:
                runFailed = True
                if abrt:
                    runFailed = "abort"

            if args.retry_until_stall:
                # Supervisor will retry, make sure that the experiment's
                # progress is NOT deleted
                runWillRetry = args.isGoingToRetry
        finally:
            if not runWillRetry:
                os.unlink(tmpDirLink)
            if expDir is not None and not runWillRetry:
                s = time.time()
                failing = True
                while time.time() - s < 10.0:
                    # Wait up to 10 seconds for the program to stop adding files
                    # to the experiment folder (child processes)
                    try:
                        shutil.rmtree(expDir)
                        failing = False
                        break
                    except OSError, e:
                        # Directory not empty
                        if e.errno != 39:
                            raise
                        print("Files still being written...")
                        time.sleep(1.0)
                if failing:
                    print("Could not remove {}".format(expDir))
                safeRollback(os.path.dirname(expDir))
    except:
        # Roll back our tag and results folders...  This catches a build fail
        print("Caught error (presumably in build): {}".format(
                traceback.format_exc()))
        print("Deleting {0} and associated tags / links".format(resultsDirRun))
        checked("git tag -d {0}".format(commitTag), nonZeroOk = [ 1 ])
        try:
            os.unlink(datedLinkRun)
        except OSError, e:
            # File does not exist is OK, we were just trying to delete it anyway
            if e.errno != 2:
                raise
        safeRollback(os.path.dirname(datedLinkRun))
        try:
            oldLink = os.readlink(latestLinkRun)
            if os.path.abspath(os.path.join(os.path.dirname(latestLinkRun),
                    oldLink)) == os.path.abspath(resultsDirRun):
                os.unlink(latestLinkRun)
                safeRollback(os.path.dirname(latestLinkRun))
        except OSError, e:
            # Link doesn't exist?
            if e.errno != 2:
                raise
        try:
            shutil.rmtree(resultsDirRun)
        except OSError, e:
            # Doesn't exist
            if e.errno != 2:
                raise
        parDir = os.path.dirname(resultsDirRun)
        try:
            if os.listdir(parDir) == [ 'INDEX' ]:
                # INDEX is only file left, remove it and remove the directory
                os.unlink(os.path.join(parDir, 'INDEX'))
                safeRollback(os.path.dirname(resultsDirRun))
            else:
                # Update the index
                updateIndex(commitTag, IndexStates.GONE)
        except OSError, e:
            # Doesn't exist
            if e.errno != 2:
                raise

        if args.retry_until_stall:
            # Get rid of experiment entirely
            shutil.rmtree(getPathForResumeKey(args.retryKey))

        # Build failed for sure!
        sys.exit(1)

    if runWillRetry:
        print("Exiting without cleaning up, supervisor will retry")
        sys.exit(2)

    # Move the RUN_SUFFIX folder to the appropriate suffix
    newSuffix = ""
    indState = IndexStates.OK
    if runFailed:
        # We failed, but not due to a build failure.
        # Move our numbered file to one like "3-fail"
        newSuffix = FAIL_SUFFIX
        indState = IndexStates.FAIL
        if runFailed == "abort":
            newSuffix = ABORT_SUFFIX
            indState = IndexStates.ABORT
    resultsDirNew = resultsDir + newSuffix

    print("Moving {0} to {1}".format(resultsDirRun, resultsDirNew))
    os.rename(resultsDirRun, resultsDirNew)

    updateIndex(commitTag, indState)

    oldLink = os.readlink(datedLinkRun)
    os.unlink(datedLinkRun)
    os.symlink(oldLink[:-len(RUN_SUFFIX)] + newSuffix, datedLink + newSuffix)

    oldLink = os.readlink(latestLinkRun)
    if (os.path.abspath(os.path.join(os.path.dirname(latestLinkRun), oldLink))
            == os.path.abspath(resultsDirRun)):
        # We were the latest test, so do the update
        os.unlink(latestLinkRun)
        os.symlink(oldLink[:-len(RUN_SUFFIX)] + newSuffix,
                latestLink + newSuffix)

    # If we get here, then we're done without hope of retry
    if args.retry_until_stall:
        shutil.rmtree(getPathForResumeKey(args.retryKey))
        os.unlink(os.path.join(resultsDirNew, "git-results-retry-key"))

    if runFailed:
        sys.exit(1)
    elif args.follow_cmd:
        r = subprocess.Popen(args.follow_cmd, shell = True,
                cwd = resultsDirNew).wait()
        if r != 0:
            raise Exception("--follow-cmd '{}' failed with non-zero return: {}"
                    .format(args.follow_cmd, r))


if __oname__ == '__main__':
    run()
