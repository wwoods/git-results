#! /usr/bin/env python2

"""Created by Walt Woods, 2014"""

from __future__ import print_function

import argparse
import datetime
import os
import random
import re
import shlex
import shutil
import subprocess
import sys
import textwrap
import threading
import time
import traceback

ABORT_SUFFIX = '-abrt'
FAIL_SUFFIX = '-fail'
RUN_SUFFIX = '-run'
SUFFIXES = [ ABORT_SUFFIX, FAIL_SUFFIX, RUN_SUFFIX, '' ]

class FolderState(object):
    """An object that tracks which files exist at init and at another time,
    and can copy changes to another folder."""

    def __init__(self, dir, resultsDir):
        """If dir is None, then this is an in-place operation, and we should
        move (rather than copy) the results."""
        self._inPlace = (dir is None)
        self._dir = dir or os.path.abspath('.')
        self._resultsDirRel = os.path.relpath(resultsDir, self._dir)
        if not self._resultsDirRel.startswith(".."):
            while True:
                rdr = os.path.split(self._resultsDirRel)[0]
                if not rdr:
                    break
                self._resultsDirRel = rdr
        self._files = set()
        self._scan(self._dir)


    def copyResultsTo(self, dir, trimCommonPaths = False):
        """Copy changes from self._dir to dir.  Use most common path."""
        allChanges = set()
        self._scanChanges(self._dir, allChanges)

        prefix = None
        for c in allChanges:
            if prefix is None:
                prefix = c
            else:
                while not c.startswith(prefix):
                    prefix = os.path.dirname(prefix)

        for c in allChanges:
            # Add 1 to len(prefix) so that we don't include the preceding slash,
            # which would make os.path.join treat it as an absolute
            target = os.path.relpath(c, self._dir)
            if trimCommonPaths:
                target = os.path.relpath(c, prefix)
            target = os.path.join(dir, target)
            safeMake(os.path.dirname(target))
            if not self._inPlace:
                shutil.copy2(c, target)
            else:
                os.rename(c, target)


    def _isBanned(self, path):
        if path == os.path.join(self._dir, self._resultsDirRel):
            return True
        return False


    def _scan(self, path):
        if self._isBanned(path):
            return
        for f in os.listdir(path):
            ff = os.path.join(path, f)
            if os.path.isfile(ff):
                self._files.add(ff)
            if os.path.isdir(ff) and not os.path.islink(ff):
                self._scan(ff)


    def _scanChanges(self, path, changeset):
        if self._isBanned(path):
            return
        for f in os.listdir(path):
            ff = os.path.join(path, f)
            if os.path.isfile(ff) and ff not in self._files:
                changeset.add(ff)
            elif os.path.isdir(ff) and not os.path.islink(ff):
                self._scanChanges(ff, changeset)



def checked(cmd, nonZeroOk = False, shell = False):
    cmd = shlex.split(cmd)
    p = subprocess.Popen(cmd, stdout = subprocess.PIPE,
            stderr = subprocess.PIPE, shell = shell)
    stdout, stderr = p.communicate()
    r = p.poll()

    if r != 0 and not nonZeroOk:
        raise Exception("Command '{0}' failed with {1}".format(cmd, r))
    return stdout


def copySymlinks(frm, to):
    """Copies all symlinks recursively from directory frm to directory to."""
    for f in os.listdir(frm):
        ffrm = os.path.join(frm, f)
        fto = os.path.join(to, f)
        if os.path.islink(ffrm):
            linkTo = os.readlink(ffrm)
            os.symlink(linkTo, fto)
        elif os.path.isdir(ffrm) and os.path.isdir(fto):
            copySymlinks(ffrm, fto)


def ensureGitignore(resultsDir):
    if not checked("git status {0} --porcelain --ignored".format(
            resultsDir)).startswith("!!"):
        with open('.gitignore', 'a') as f:
            f.write("\n/{0}".format(resultsDir))


def tee(infile, *files):
    """Thanks to http://stackoverflow.com/a/4985080/160205, tee lines from the
    given file to one or more other files.
    """
    def fanout():
        for line in iter(infile.readline, ''):
            for f in files:
                f.write(line)
        infile.close()
    t = threading.Thread(target = fanout)
    t.daemon = True
    t.start()
    return t


def runExperiment(dir, resultsDir, commitTag, trimCommonPaths):
    """Given a directory to initialize and run our experiment in 'dir', run it
    and put results in 'resultsDir'

    dir can be None for current dir (not a temporary directory!)
    """

    if dir is None:
        dirRelative = '.'
    else:
        dirRelative = dir
        dir = os.path.abspath(dir)
    resultsDirRelative = resultsDir
    resultsDir = os.path.abspath(resultsDir)
    odir = os.getcwd()
    tmpDirLink = os.path.join(resultsDir, 'git-results-tmp')
    try:
        os.symlink(os.path.abspath(dir or '.'), tmpDirLink)

        if dir is not None:
            os.chdir(dir)
            checked('git init')
            checked('git remote add origin file://{0}'.format(odir))
            checked('git fetch origin {0}'.format(commitTag))
            checked('git reset --hard FETCH_HEAD')
            copySymlinks(odir, dir)
            for grFile in [ "git-results-build", "git-results-run" ]:
                shutil.copy2(os.path.join(odir, grFile), os.path.join(dir,
                        grFile))

        preBuild = time.time()

        print("Building {0} in {1}".format(commitTag, dirRelative))
        # stderr redirection benefits nosetests, mainly.
        p = subprocess.Popen(os.path.abspath('./git-results-build'),
                shell = True, stdout = subprocess.PIPE,
                stderr = subprocess.STDOUT)
        thread = tee(p.stdout, sys.stdout)
        thread.join()
        r = p.wait()
        if r != 0:
            print("== BUILD FAILED ==")
            sys.exit(1)

        # Now that we've built it, snapshot the folder so we can copy whatever
        # changed as results.  We'll be a little smart and take off the greatest
        # common path too...
        fs = FolderState(dir, resultsDir)

        print("Running {0} in {1}".format(commitTag, dirRelative))
        print("=" * 79)
        print("=" * 79)
        preRun = time.time()

        threads = None
        didAbort = False
        try:
            # Special handling for our runner script
            line_buffered = 1
            output = open('{0}/stdout'.format(resultsDir), 'w', line_buffered)
            error = open('{0}/stderr'.format(resultsDir), 'w', line_buffered)
            p = subprocess.Popen(os.path.abspath('./git-results-run'), shell = True,
                    stdout = subprocess.PIPE, stderr = subprocess.PIPE)
            threads = [ tee(p.stdout, output, sys.stdout),
                    tee(p.stderr, error, sys.stderr) ]
            [ t.join() for t in threads ]
            r = p.wait()
        except KeyboardInterrupt:
            # Child got Ctrl+C,
            print("== CTRL+C caught by git-results; child should exit as per "
                    "CTRL+C semantics")
            [ t.join() for t in threads ]
            r = p.wait()
            didAbort = True

        print("=" * 79)
        print("=" * 79)

        # If we reach here, everything ran OK, so copy files
        print("Copying results to {0}".format(resultsDirRelative))
        fs.copyResultsTo(resultsDir, trimCommonPaths)

        allDone = time.time()
        with open(os.path.join(resultsDir, 'git-results-message'), 'a') as f:
            f.write("\n\n")
            f.write("{0} after {1}s\n".format("OK" if r == 0 else "FAIL",
                    allDone - preRun))
            f.write("Build took {0}s\n".format(preRun - preBuild))

        if r != 0:
            error.write(("\n\ngit-results detected abnormal program "
                    "termination: {0}\n").format(r))
            print("Non-zero exit status after {0}: {1}".format(allDone - preRun,
                    r))
        else:
            print("OK after {0}".format(allDone - preRun))
        return r, didAbort
    finally:
        os.chdir(odir)
        os.unlink(tmpDirLink)


def safeMake(path):
    try:
        os.makedirs(path)
    except OSError, e:
        # exists
        if e.errno != 17:
            raise


def setupExperiment(resultsDir, shouldCommit, tag, message):
    """Sets up the experiment skeleton and commits the git repo to an acceptable
    state.

    Returns the directory for results (absolute path), dated symlink path (for
    rollback / updated), latest symlink path, and the commit tag to run.
    """
    resultsBaseRelative = resultsDir
    resultsDir = os.path.abspath(resultsDir)
    if not os.path.lexists(os.path.join(resultsDir, ".git")):
        curdir = os.getcwd()
        safeMake(resultsDir)
        os.chdir(resultsDir)
        checked("git init")
        os.chdir(curdir)

    if not os.path.lexists("{0}/.gitignore".format(resultsDir)):
        # If we don't make a file, it looks like results is always ignored even
        # though it isn't.  Luckily, we need a .gitignore anyway
        with open("{0}/.gitignore".format(resultsDir), 'w') as f:
            f.write("/.tmp\n")

    # Now that it's made, make sure it's ignored
    ensureGitignore(resultsBaseRelative)

    # Allow / encourage running same tag several times.  We'll use /1, /2, etc
    n = 1
    if os.path.lexists(os.path.join(resultsBaseRelative, tag)):
        for run in os.listdir(os.path.join(resultsBaseRelative, tag)):
            for s in SUFFIXES:
                if s and run.endswith(s):
                    run = run[:-len(s)]
            n = max(n, int(run) + 1)
    pureTag = tag
    tagDir = os.path.join(resultsBaseRelative, tag + "/{0}".format(n))
    tag = tag + "/{0}".format(n)
    gitTag = "{0}/{1}".format(resultsBaseRelative, tag)

    if not message:
        cleanMessage = gitTag
    else:
        cleanMessage = message.replace('"', '\\"').replace("&", "\\&"
                ).replace("|", "\\|").replace("!", "\\!")

    # Check the state of our git repo
    if checked("git status --porcelain").strip():
        # Need to commit, if we can
        if not shouldCommit:
            sys.stderr.write("Repository has unsaved changes; use -c to commit "
                    "automatically.\n")
            sys.exit(1)

        # Make sure git-results-build and git-results-run are ignored
        gb = checked("git status git-results-build --porcelain --ignored")
        if gb and not gb.startswith("!!"):
            # Would be added.  Don't do that!
            with open(".gitignore", "a") as f:
                f.write("\n/git-results-build")
        gb = checked("git status git-results-run --porcelain --ignored")
        if gb and not gb.startswith("!!"):
            # Same
            with open(".gitignore", "a") as f:
                f.write("\n/git-results-run")

        # If this fails, the branch didn't exist or we're already on it, both
        # of which are fine
        checked("git checkout -B git-results")
        checked("git add -A .")
        checked('git commit -m "{0}"'.format(cleanMessage))

    curCommit = checked("git rev-parse HEAD").strip()

    # Actually make our folder
    tagDirRun = tagDir + RUN_SUFFIX
    safeMake(tagDirRun)

    # Dated linkage
    now = datetime.datetime.now()
    dated = os.path.join(resultsDir, 'dated', now.strftime("%Y"),
            now.strftime("%m"))
    safeMake(dated)

    linkAs = os.path.join(dated, "{0}-{1}{2}".format(now.strftime("%d"), tag,
            RUN_SUFFIX))
    safeMake(os.path.dirname(linkAs))
    parentLevel = 2 + len(tag.split('/'))
    os.symlink(os.path.relpath(tagDirRun, os.path.dirname(linkAs)), linkAs)

    latestLinkAs = os.path.join(resultsDir, 'latest', pureTag + RUN_SUFFIX)
    safeMake(os.path.dirname(latestLinkAs))
    for s in SUFFIXES:
        linkPath = os.path.join(resultsDir, 'latest', pureTag + s)
        if os.path.lexists(linkPath):
            os.unlink(linkPath)
    os.symlink(os.path.relpath(tagDirRun, os.path.dirname(latestLinkAs)),
            latestLinkAs)

    # Add our tag to the git repo
    checked('git tag -a -m "{0}" {1}'.format(cleanMessage, gitTag))

    # Write our message file
    with open(os.path.join(tagDirRun, "git-results-message"), "w") as f:
        f.write("{0}\n{1}\n".format(gitTag, "=" * min(79, len(gitTag))))
        if message:
            f.write("{0}\n".format(message))
        f.write("\nCommit: {0}".format(curCommit))
        f.write("\n\ngit-results-run\n---------------\n")
        f.write(open('git-results-run').read())
        f.write("\n\ngit-results-build\n-----------------\n")
        f.write(open('git-results-build').read())

    return tagDirRun, linkAs, latestLinkAs, gitTag


def checkTag(s):
    """Takes a string s and returns it, if it is a tag."""
    if re.search("^[a-zA-Z0-9_/-]+$", s) is None:
        raise ValueError("Tag must match regex [a-zA-Z0-9_-/]+")
    if s.startswith('dated'):
        raise ValueError("Tag may not start with 'dated'")
    if s.startswith('latest'):
        raise ValueError("Tag may not start with 'latest'")
    if s.strip('/') != s:
        raise ValueError("Tag may not begin or end with '/'")
    isInt = False
    try:
        int(s.split('/')[-1])
        isInt = True
    except ValueError:
        pass
    if isInt:
        raise ValueError("Tag may not end in a number")
    return s


def safeRollback(d):
    """Delete d and all parent directories (up to most common directory with
    current directory)
    """
    try:
        os.removedirs(d)
    except OSError, e:
        # Directory not empty
        if e.errno != 39:
            raise


def _processTagArgs(args, pathArg, dirArg, *tagArgs):
    """Sort out -d and -p args with arbitrary number of tags.  args.dir is
    populated with a list of directories corresponding with tags, in order.

    Also responsible for default dir of "results"
    """
    if getattr(args, pathArg, None) and getattr(args, dirArg, None):
        raise ArgumentError("-d and -p are incompatible")

    oldDir = (getattr(args, dirArg) or "results").rstrip()
    newDirs = []

    for tagArg in tagArgs:
        tag = getattr(args, tagArg)
        if getattr(args, pathArg):
            # Override dir and tag values given -p
            path = tag
            tag = ""
            while True:
                s = os.path.split(path)
                if s[0]:
                    if tag:
                        tag = '/'.join([ s[1], tag ])
                    else:
                        tag = s[1]
                    path = s[0]
                else:
                    newDirs.append(s[1])
                    tag = tag.strip('/')
                    break
        else:
            newDirs.append(oldDir)
        checkTag(tag)
        setattr(args, tagArg, tag)

    setattr(args, dirArg, newDirs)


def _auditMove(pathFrom, pathTo):
    """Audits that the given matchingTags can be moved from pathFrom to pathTo
    without collisions.

    Returns matchingTags
    """
    gitTags = [ t.strip() for t in checked(
            "git tag -l '{0}' '{0}/*'".format(pathFrom)).strip().split('\n') ]
    matchingTags = []
    for src in gitTags:
        if not src.startswith(pathFrom):
            raise ValueError("Tag {0} doesn't start with {1}".format(src,
                    pathFrom))
        dest = pathTo + src[len(pathFrom):]
        # Check that the source folder exists, not just the tag in git
        suffix = None
        for s in SUFFIXES:
            if os.path.lexists(src + s):
                if s == "-run":
                    sys.stderr.write("Cannot move/link tag that is running: {0}"
                            .format(src))
                    sys.exit(1)
                suffix = s
                break

        if suffix is None:
            sys.stderr.write("Cannot find data for {0}".format(src))
        matchingTags.append(( src, dest, suffix ))

        # Check that the destination doesn't exist
        existingForms = []
        if checked("git tag -l '{0}'".format(dest)).strip():
            existingForms.append("tag")
        for s in SUFFIXES:
            if os.path.lexists(dest + s):
                existingForms.append("filesystem" + s)
        if existingForms:
            sys.stderr.write("Destination tag {0} exists ({1})".format(
                    dest, ', '.join(existingForms)))
            sys.exit(1)

    return matchingTags


class LatestTracker(object):
    def __init__(self):
        """Keeps track of moved stuff, sorts out which should be the new latest
        link, does the update."""
        self._entries = {}


    def addTagDir(self, srcDir, tagDir, suffix):
        results, path = tagDir.split('/', 1)
        tagLatest, tagNumber = (results + '/latest/' + path).rsplit('/', 1)

        results, path = srcDir.split('/', 1)
        srcLatest, srcNumber = (results + '/latest/' + path).rsplit('/', 1)

        number = int(tagNumber.split('-')[0])
        if tagLatest in self._entries:
            if number > self._entries[tagLatest][0]:
                self._entries[tagLatest] = (number, suffix, tagDir, srcLatest)
        else:
            self._entries[tagLatest] = (number, suffix, tagDir, srcLatest)


    def commit(self, deleteOldLatest = False):
        """Make new latest symlinks"""
        # Update latest; each matchingTag's last part is the trial number, and
        # we should link the highest
        for path, (number, suffix, target, srcLatest
                ) in self._entries.iteritems():
            safeMake(os.path.dirname(path + suffix))
            os.symlink(os.path.relpath(target, os.path.dirname(path)),
                    path + suffix)
            if deleteOldLatest:
                # srcLatest + suffix must be it, but it may not exist due to 
                # e.g. old version of code.  Best be safe
                for s in SUFFIXES:
                    if os.path.lexists(srcLatest + s):
                        os.unlink(srcLatest + s)


def _runLink(args):
    ap = argparse.ArgumentParser(description = "Link one or more tagged "
            "results to a new location (which refers to the original).")
    ap.add_argument("-p", "--path", action = 'store_true', help = "Same as -p "
            "for normal git results calls; means that the paths specified "
            "include the results directory as the first element.  Supercedes "
            "-d.  Must match for both paths given.")
    ap.add_argument("-d", "--dir", help = "Directory used to store results.")
    ap.add_argument("tag_from")
    ap.add_argument("tag_to")
    args = ap.parse_args(args)
    _processTagArgs(args, "path", "dir", "tag_from", "tag_to")
    pathFrom = '/'.join([ args.dir[0], args.tag_from ])
    pathTo = '/'.join([ args.dir[1], args.tag_to ])

    matchingTags = _auditMove(pathFrom, pathTo)

    # Do the links
    latestTracker = LatestTracker()
    for tagSrc, tagDest, suffix in matchingTags:
        dirSrc = tagSrc + suffix
        dirDest = tagDest + suffix
        safeMake(os.path.dirname(dirDest))
        os.symlink(os.path.relpath(dirSrc, os.path.dirname(dirDest)), dirDest)
        tagMsg = checked("git tag -l -n1000 {0}".format(tagSrc)).strip()[
                len(tagSrc):].strip()
        checked("git tag -a -m '{0}' {1} {2}".format(tagMsg.replace("'", "\'"),
                tagDest, tagSrc))
        latestTracker.addTagDir(dirSrc, dirDest, suffix)
    latestTracker.commit()


def _runMove(args):
    ap = argparse.ArgumentParser(description = "Move one or more tagged "
            "results to a different tag.")
    ap.add_argument("-p", "--path", action = 'store_true', help = "Same as -p "
            "for normal git results calls; means that the paths specified "
            "include the results directory as the first element.  Supercedes "
            "-d.  Must match for both paths given.")
    ap.add_argument("-d", "--dir", help = "Directory used to store results.")
    ap.add_argument("tag_from")
    ap.add_argument("tag_to")
    args = ap.parse_args(args)
    _processTagArgs(args, "path", "dir", "tag_from", "tag_to")
    pathFrom = '/'.join([ args.dir[0], args.tag_from ])
    pathTo = '/'.join([ args.dir[1], args.tag_to ])

    matchingTags = _auditMove(pathFrom, pathTo)

    # tag path : [ Y, M, D ]
    tagDates = {}
    def walkDateDir(path, tag, dateInfo):
        if os.path.islink(path):
            # Strip off the fail / success / whatever status
            if '-' in tag.rsplit('/', 1)[1]:
                tag = tag.rsplit('-', 1)[0]
            tagDates[tag] = dateInfo
        elif os.path.isdir(path):
            for p in os.listdir(path):
                walkDateDir(os.path.join(path, p), '/'.join([ tag, p ]),
                        dateInfo)

    dateBase = os.path.join(args.dir[0], 'dated')
    for year in os.listdir(dateBase):
        yearBase = os.path.join(dateBase, year)
        for month in os.listdir(yearBase):
            monthBase = os.path.join(yearBase, month)
            for dayHyphen in os.listdir(monthBase):
                day, tagStart = dayHyphen.split('-', 1)
                walkDateDir(os.path.join(monthBase, dayHyphen),
                        '/'.join([ args.dir[0], tagStart ]),
                        [ year, month, day ])

    # Everything seems OK, rename it all.  Start with all of the filesystem
    # changes since we can run git results resync (once implemented) afterwards.
    latestTracker = LatestTracker()
    for tagSrc, tagDest, suffix in matchingTags:
        dirSrc = tagSrc + suffix
        dirDest = tagDest + suffix

        safeMake(os.path.dirname(dirDest))
        os.rename(dirSrc, dirDest)
        safeRollback(os.path.dirname(dirSrc))
        tagMsg = checked("git tag -l -n1000 {0}".format(tagSrc)).strip()[
                len(tagSrc):].strip()
        checked("git tag -a -m '{0}' {1} {2}".format(tagMsg.replace("'", "\'"),
                tagDest, tagSrc))
        checked("git tag -d {0}".format(tagSrc))
        latestTracker.addTagDir(dirSrc, dirDest, suffix)

        # We have to update any dated links...
        dateInfo = tagDates.get(tagSrc)
        if dateInfo:
            sansResultDir = dirSrc.split('/', 1)[1]
            oldLink = os.path.join(args.dir[0], 'dated', dateInfo[0],
                    dateInfo[1], dateInfo[2] + '-' + sansResultDir)
            os.unlink(oldLink)
            safeRollback(os.path.dirname(oldLink))
            targLink = os.path.join(args.dir[1], 'dated', dateInfo[0],
                    dateInfo[1], dateInfo[2] + '-' + dirDest.split('/', 1)[1])
            safeMake(os.path.dirname(targLink))
            os.symlink(os.path.relpath(dirDest, os.path.dirname(targLink)),
                    targLink)
    latestTracker.commit(True)


def run(programArgs = None):
    if not os.path.isdir('.git'):
        print("Must be used in a git directory!")
        sys.exit(1)

    if programArgs is None:
        programArgs = sys.argv[1:]

    if programArgs[0] == "move":
        return _runMove(programArgs[1:])
    elif programArgs[0] == "link":
        return _runLink(programArgs[1:])

    ap = argparse.ArgumentParser(description = "A git extension for cataloging "
            "computation results.  Subcommands available: move, link (e.g. "
            "git results move -h)")
    ap.add_argument("-d", "--dir", help = "Directory used "
            "to store results.  Automatically created and set up as a git "
            "repo.  Also automatically added to .gitignore")
    ap.add_argument("-p", "--path", action = 'store_true',
            help = "Supercedes -d and normal default tag argument.  The first "
                "path element in the tag argument becomes the results "
                "directory, and the rest becomes the tag.  Useful for e.g. "
                "tab completion in a console.")
    ap.add_argument("-i", "--in-place", action = 'store_true',
            help = "Do the build in place.  If you use this, you can't run "
                "several simultaneous git results calls on the same repo.  "
                "Recommended when you're trying to get a build working, or "
                "testing short experiments, but not otherwise.")
    ap.add_argument("-c", "--commit", action = 'store_true',
            help = "If there are uncommitted changes, automatically commit "
                "with the message as given.")
    ap.add_argument("-t", "--trim", action = 'store_true',
            help = "Trim output paths to most common denominator.  That is, if "
                "the application creates folder results/a.txt, then since the "
                "results/ path is part of all created files, it will be "
                "trimmed (leaving just a.txt).")
    ap.add_argument("-m", "--message", help = "Commit message / "
            "git-results-message content paired with results.  If unspecified, "
            "we'll pop open an editor for you (like git commit)")
    ap.add_argument("tag", help = textwrap.dedent("""
            Path to organize these results under.  For instance, giving a tag of parity/squids
            will create a git tag for the commit as results/parity/squids, and will create the
            folders "parity" and subfolder "squids" to store the results in.  It is an error
            to specify a tag that already exists.  "dated" is also an invalid option, as that is
            a unique folder created by git-results to help with indexing results by date.
            "latest" is invalid as well, referring to another unique folder."""))
    args = ap.parse_args(programArgs)

    if not args.message:
        raise NotImplementedError("You need to use the -m flag to pass a "
                "message to tie to this tag.")

    _processTagArgs(args, "path", "dir", "tag")
    # _processTagArgs sets args.dir to a list of directories.  For the main
    # functionality, we only have one dir.
    args.dir = args.dir[0]

    if not os.path.isfile('git-results-build'):
        print(textwrap.dedent("""
                To use git-results, two files are required: git-results-run and
                git-results-build.  Even if git-results-build is empty, it must exist.
                git-results-build should be a script that builds resources used by
                git-results-run."""))

    if not os.path.isfile('git-results-run'):
        print(textwrap.dedent("""
                To use git-results, you must have a git-results-run file in your
                repository's root.  This file must contain a single shell-executable
                line of text that runs your experiment."""))
        sys.exit(1)

    # OK, run the experiment
    resultsDirRun, datedLinkRun, latestLinkRun, commitTag = setupExperiment(
            args.dir, args.commit, args.tag, args.message)
    resultsDir = resultsDirRun[:-len(RUN_SUFFIX)]
    datedLink = datedLinkRun[:-len(RUN_SUFFIX)]
    latestLink = latestLinkRun[:-len(RUN_SUFFIX)]

    runFailed = False
    try:
        # NOTE - For e.g. MPI, or other network tasks, we do not use the
        # standard tempfile methods.  The path has to be accessible on all
        # machines.
        expDir = None
        if args.in_place:
            expDir = None
        else:
            safeMake(os.path.join(args.dir, ".tmp"))
            while True:
                randName = "".join([
                        random.choice("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")
                        for _ in range(8) ])
                expDir = os.path.join(args.dir, ".tmp", randName)
                try:
                    os.mkdir(expDir)
                    break
                except OSError, e:
                    # Already exists
                    if e.errno != 17:
                        raise
        try:
            r, abrt = runExperiment(expDir, resultsDirRun, commitTag, args.trim)
            if r != 0:
                runFailed = True
                if abrt:
                    runFailed = "abort"
        finally:
            if expDir is not None:
                shutil.rmtree(expDir)
                safeRollback(os.path.dirname(expDir))
    except:
        # Roll back our tag and results folders...
        traceback.print_exc()
        print("Deleting {0} and associated tags / links".format(resultsDirRun))
        checked("git tag -d {0}".format(commitTag))
        os.unlink(datedLinkRun)
        safeRollback(os.path.dirname(datedLinkRun))
        oldLink = os.readlink(latestLinkRun)
        if os.path.abspath(os.path.join(os.path.dirname(latestLinkRun),
                oldLink)) == os.path.abspath(resultsDirRun):
            os.unlink(latestLinkRun)
            safeRollback(os.path.dirname(latestLinkRun))
        shutil.rmtree(resultsDirRun)
        safeRollback(os.path.dirname(resultsDirRun))
        # Build failed for sure!
        sys.exit(1)

    # Move the RUN_SUFFIX folder to the appropriate suffix
    newSuffix = ""
    if runFailed:
        # We failed, but not due to a build failure.
        # Move our numbered file to one like "3-fail"
        newSuffix = FAIL_SUFFIX
        if runFailed == "abort":
            newSuffix = ABORT_SUFFIX

    print("Moving {0} to {1}".format(resultsDirRun, resultsDir + newSuffix))
    os.rename(resultsDirRun, resultsDir + newSuffix)

    oldLink = os.readlink(datedLinkRun)
    os.unlink(datedLinkRun)
    os.symlink(oldLink[:-len(RUN_SUFFIX)] + newSuffix, datedLink + newSuffix)

    oldLink = os.readlink(latestLinkRun)
    if (os.path.abspath(os.path.join(os.path.dirname(latestLinkRun), oldLink))
            == os.path.abspath(resultsDirRun)):
        # We were the latest test, so do the update
        os.unlink(latestLinkRun)
        os.symlink(oldLink[:-len(RUN_SUFFIX)] + newSuffix,
                latestLink + newSuffix)

    if runFailed:
        sys.exit(1)


if __name__ == '__main__':
    run()
